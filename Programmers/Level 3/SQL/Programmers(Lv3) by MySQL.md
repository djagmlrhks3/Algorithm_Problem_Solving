# Programmers(Lv3) by MySQL

### 없어진 기록 찾기

> ON INS.ANIMAL_ID = OUTS.ANIMAL_ID 대신 USING (ANIMAL_ID)도 가능!

```mysql
SELECT OUTS.ANIMAL_ID, OUTS.NAME
FROM ANIMAL_OUTS AS OUTS
LEFT JOIN ANIMAL_INS AS INS
ON INS.ANIMAL_ID = OUTS.ANIMAL_ID
WHERE INS.DATETIME IS NULL
ORDER BY OUTS.ANIMAL_ID
```



### 있었는데요 없었습니다

```mysql
SELECT OUTS.ANIMAL_ID AS ANIMAL_ID, OUTS.NAME AS NAME
FROM ANIMAL_OUTS AS OUTS
LEFT JOIN ANIMAL_INS AS INS
ON INS.ANIMAL_ID = OUTS.ANIMAL_ID
WHERE INS.DATETIME > OUTS.DATETIME
ORDER BY INS.DATETIME;
```



### 오랜 기간 보호한 동물(1)

```mysql
SELECT INS.NAME, INS.DATETIME
FROM ANIMAL_INS AS INS
LEFT JOIN ANIMAL_OUTS AS OUTS
USING (ANIMAL_ID)
WHERE OUTS.DATETIME IS NULL
ORDER BY INS.DATETIME
LIMIT 3;
```



### 보호소에서 중성화한 동물

> 중성화했으면 성별이 바뀌었을 것이므로 !=로 했다...

```mysql
SELECT OUTS.ANIMAL_ID, OUTS.ANIMAL_TYPE, OUTS.NAME
FROM ANIMAL_OUTS AS OUTS
INNER JOIN ANIMAL_INS AS INS
ON INS.ANIMAL_ID = OUTS.ANIMAL_ID
WHERE INS.SEX_UPON_INTAKE != OUTS.SEX_UPON_OUTCOME
ORDER BY INS.ANIMAL_ID
```



> 좀 더 정확한 답

```mysql
SELECT INS.ANIMAL_ID, INS.ANIMAL_TYPE, INS.NAME
FROM ANIMAL_INS AS INS
LEFT JOIN ANIMAL_OUTS AS OUTS
USING (ANIMAL_ID)
WHERE (INS.SEX_UPON_INTAKE NOT LIKE '%Spayed%' AND INS.SEX_UPON_INTAKE NOT LIKE '%Neutered%') AND (OUTS.SEX_UPON_OUTCOME LIKE '%Spayed%' OR OUTS.SEX_UPON_OUTCOME LIKE '%Neutered%')
ORDER BY INS.ANIMAL_ID
```

